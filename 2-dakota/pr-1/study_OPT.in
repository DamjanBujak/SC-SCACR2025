# Dakota input for optimization study
# Purpose: configure environment, method (optpp_q_newton), model, variables, interface to Python driver, and responses.

environment
	# Configure tabular/plain outputs and restart files
	tabular_data
		# Where to write tabular results of evaluations (parameters and responses)
		tabular_data_file "tabular.txt"
	# Redirect Dakota's standard output and error to files for easier debugging
	output_file "dakota.out"
	error_file "dakota.err"
	# Save restart data to allow restarts or post-processing by Dakota tools
	write_restart "dakota.rst"
	# Control results formatting in output; 'text' enables descriptor-labeled results blocks
	results_output
		text

method
	# User-defined identifier for this method (name only, not the type)
	id_method "parameter_study"
	# Chosen optimization algorithm: OPT++ quasi-Newton (local gradient-based)
	optpp_q_newton
	    # Optimization stopping tolerance on the norm of the gradient (smaller = stricter)
	    convergence_tolerance 0.01
	# Link this method to the model defined below
	model_pointer = 'model1'

model
	# User-defined identifier for the model
	id_model "model1"
	# A single analysis per function evaluation (no sub-models)
	single
		# Connect the model to interface, variables, and responses by id
		interface_pointer "interface1"
	variables_pointer "variables1"
	responses_pointer "responses1"

variables
	# User-defined identifier for the variables block
	id_variables "variables1"
	# Mark which variable types are active in the study (here: only design variables are optimized)
	active design

    # State variables (not optimized); used to parameterize analyses and kept fixed by optimizer
    continuous_state 3
		# Initial values for the 3 state variables (order matches descriptors)
		initial_state    2	       1           0.5
		# Human-friendly names for the state variables
		descriptors    "hm0"  "gamma_beta"  "gamma_f"

	# Design variables (optimized by the method)
	continuous_design = 1
    	# Starting value for the design variable
    	initial_point    2.0    
    	# Box constraints: upper and lower bounds
    	upper_bounds     5.0    
    	lower_bounds     1.0   
		# Name for the design variable
		descriptors      "rc"   

interface
	# User-defined identifier for the interface block
	id_interface "interface1"
	# External analysis driver command; Dakota will invoke this for each evaluation
	analysis_drivers "python eurotop-driver.py"
		# Use process forking with parameter/result files in per-run work directories
		fork
			# Names of the parameter file written by Dakota and the results file read back
			parameters_file "params.in"
			results_file "results.out"
			# Configure where runs are executed and what files to copy into each run directory
			work_directory
				# Root work directory for runs (subdirectories are created per evaluation)
				named "workdir/run"
				# Files to copy into each work directory so the driver can run self-contained
				copy_files 'eurotop-driver.py' 'eurotop-template.py'
				# Append a unique tag to per-evaluation directories (e.g., run.1, run.2, ...)
				directory_tag
				# Preserve work directories after the run (useful for debugging)
				directory_save
	# Allow multiple evaluations to run concurrently (asynchronously)
	asynchronous
		# Maximum number of concurrent evaluations; tune to available cores/resources
		evaluation_concurrency 8

responses
	# User-defined identifier for the responses block (what the driver returns)
	id_responses "responses1"
	# Number of scalar response values (e.g., residuals) returned by the driver
	calibration_terms 1
		# Descriptor for the response
		descriptors "residual"
	# Let Dakota compute gradients numerically (finite differences) by perturbing design vars
	numerical_gradients
	# Do not request Hessians from the driver (nor compute them)
	no_hessians
